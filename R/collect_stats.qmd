# Libraries

```{r}
#| include: false
library(sf)
library(tidyverse)
library(here)
library(units)
library(knitr)
```

# Source Data

```{r}
#| include: false

source(knitr::purl(here("R", "load_data.qmd")))
```

# Source Functions

```{r}
#| include: false
source(knitr::purl(here("R", "separate_functions.qmd")))
```

# Collect Stats

```{r}
system.time({
  # create a vector of unique combinations of width_paddock and height_paddock
paddock_dims <- expand_grid(width_paddock = 1:4, height_paddock = 1:4)

# create an empty data frame to store the results
results_df <- data.frame()

#  loop through each property ID
for (i in seq_along(limit_lu$cat)) {

 # loop through each row of the paddock_dims data frame and perform the analysis
  for (j in seq_along(paddock_dims$width_paddock)){
    
    w = paddock_dims$width_paddock[j]
    h= paddock_dims$height_paddock[j]

    property_id <- as.integer(limit_lu$cat[i])
    print(paste('current iteration:', i,j, 'ratio',w,'/',h))
  # Select Property
  property_boundary <- select_property(property_id)
  
  # Riparian Corridor check
  riparian_corridor <- riparian_buffer()
  
  # Input of Paddock and Hedgerow Dimensions
  pad_hedg_dim <- property_dimensions(
    paddock_area = 999000,
    hedgerow_width = 50,
    width_paddock = paddock_dims$width_paddock[j],
    height_paddock = paddock_dims$height_paddock[j],
    tol = 0.01,
    new_dim = NULL,
    max_iter = 500)
  
  # Create Grid , Rotate, Cut With Property
  property_grid <- grid_rotate()
  
  # Cut Grid w/ River
  property_fragment <- riparian_cut()

  # Create Forest Reserve â‰¥ 25% & \< 28%
  forest_reserve <- reserve()
  
  # Property w/o reserve area
  property_remaining <- no_reserve_area()

  # Hedgerows
  #Check for errors
print('h')
  hedgerows <- tryCatch({
    make_hedges()
    },
  error = function(e) {
    message("Error: ", e)
    
    paddocks <- NULL
    final_hedgerow <- NULL
    
    # Final Areas
  statistics <- tibble(
    id = property_boundary$cat,
    property_area = st_area(property_boundary) |> drop_units(),
    property_units = 'm^2',
    
    
    fr_area = st_area(forest_reserve) |> drop_units() ,
    fr_units = 'm^2',
    fr_per = round((st_area(forest_reserve) / st_area(property_boundary)) * 100,2) |> drop_units() ,
    
    paddocks_area = NA,
    paddocks_units = NA,
    paddocks_per =NA,
    
    hedgerow_area = NA,
    hedgerow_per = NA,
    ratio_x = w,
    ratio_y = h)

  
    
    # Add column for errors in paddocks/hedgerows
    if (is.null(paddocks)) {
      statistics$error_paddocks <- "Unable to create paddocks"
      } else {
      statistics$error_paddocks <- ifelse(sum(is.null(st_length(paddocks))) > 0, "Unable to create multistringlines", NA)
    }
    if(is.null(final_hedgerow)) {
      statistics$error_hedgerow <- "Unable to create hedgerows"
    } else {
      statistics$error_hedgerow <- ifelse(sum(is.null(st_length(final_hedgerow))) > 0, "Unable to create multistringlines", NA)}
      
      results_df <- bind_rows(results_df, statistics)
    return(statistics)
      
      }
  )

        #Cut off buffer that extends over property boundary
  
  if(is.data.frame(hedgerows)){
    results_df <- bind_rows(results_df, hedgerows)
    next
  }
  else{
    hedge <- st_erase(hedgerows,property_boundary) 
    hedges <- st_difference(hedgerows, hedge)
    }
  
print('p')  
  # Paddocks
  paddocks <- tryCatch(
    make_paddocks(),
  error = function(e) {
    message("Error: ", e)
    
    paddocks <- NULL
    final_hedgerow <- NULL
    
    # Final Areas
  statistics <- tibble(
    id = property_boundary$cat,
    property_area = st_area(property_boundary) |> drop_units(),
    property_units = 'm^2',
    
    
    fr_area = st_area(forest_reserve) |> drop_units() ,
    fr_units = 'm^2',
    fr_per = round((st_area(forest_reserve) / st_area(property_boundary)) * 100,2) |> drop_units() ,
    
    paddocks_area = NA,
    paddocks_units = NA,
    paddocks_per =NA,
    
    hedgerow_area = NA,
    hedgerow_per = NA,
    ratio_x = w,
    ratio_y = h)

  
    
    # Add column for errors in paddocks/hedgerows
    if (is.null(paddocks)) {
      statistics$error_paddocks <- "Unable to create paddocks"
      } else {
      statistics$error_paddocks <- ifelse(sum(is.null(st_length(paddocks))) > 0, "Unable to create multistringlines", NA)
    }
    if(is.null(final_hedgerow)) {
      statistics$error_hedgerow <- "Unable to create hedgerows"
    } else {
      statistics$error_hedgerow <- ifelse(sum(is.null(st_length(final_hedgerow))) > 0, "Unable to create multistringlines", NA)}
      
      results_df <- bind_rows(results_df, statistics)
    return(statistics)
      
      }
  )
  
  if(is.data.frame(paddocks)){
    results_df <- bind_rows(results_df, hedgerows)
    next
  }
  else{
   
  # If there is a corridor cut edges
  if(is.null(riparian_corridor) == FALSE) {
    riparian_area <- round(st_area(riparian_corridor),2)
    riparian_area_per <-
      (st_area(riparian_corridor) / st_area(property_boundary)) * 100
    final_hedgerow <- st_difference(hedges, riparian_corridor)
    
  } else{
    riparian_area <- NULL
    riparian_area_per <- NULL
    final_hedgerow <- hedgerows
  }
  }
  
  
  
  
  # Final Areas
  statistics <- tibble(
    id = property_boundary$cat,
    property_area = st_area(property_boundary) |> drop_units(),
    property_units = 'm^2',
    
    
    fr_area = st_area(forest_reserve) |> drop_units() ,
    fr_units = 'm^2',
    fr_per = round((st_area(forest_reserve) / st_area(property_boundary)) * 100,2) |> drop_units() ,
    
    
    paddocks_area = ifelse(!is.null(paddocks[1]), round(sum(st_area(paddocks)) / st_area(property_boundary),2),NA),
    paddocks_units = 'm^2',
    paddocks_per = ifelse(!is.null(paddocks[1]),round(sum(st_area(paddocks)) / st_area(property_boundary),2),NA),
    
    
    
    hedgerow_area = ifelse(is.null(final_hedgerow), NA, st_area(final_hedgerow)),
    hedgerow_per = round((st_area(final_hedgerow) / st_area(property_boundary)) * 100,2) |> drop_units(),
    
    
    ratio_x = w,
    ratio_y = h)

  
    
    # Add column for errors in paddocks/hedgerows
    if (is.null(paddocks)) {
      statistics$error_paddocks <- "Unable to create paddocks"
    } else {
      statistics$error_paddocks <- ifelse(sum(is.na(st_length(paddocks))) > 0, "Unable to create multistringlines", NA)
    }
    if (is.null(final_hedgerow)) {
      statistics$error_hedgerow <- "Unable to create hedgerows"
    } else {
      statistics$error_hedgerow <- ifelse(sum(is.na(st_length(final_hedgerow))) > 0, "Unable to create multistringlines", NA)
          # add results to the dataframe

    }
  results_df <- bind_rows(results_df, statistics)
  }
}

# save the final dataframe
saveRDS(results_df, "results.rds")})
```

Runtime performance: You can use the system.time() function to measure the execution time of your code. For example, you can wrap your code in system.time({ ... }) to get the execution time of the entire block of code. This will print the elapsed time, the CPU time used by the system, and the CPU time used by the user. You can also use the microbenchmark package to get more precise measurements of the execution time.

Memory usage: You can use the profvis package to profile your code and visualize the memory usage of each function. This can help you identify which functions are using the most memory and optimize your code accordingly.

Code quality: You can use tools like lintr to check for coding standards and potential errors in your code. This can help you write more maintainable and error-free code.

Functional correctness: You can use unit tests to ensure that your code is working correctly. You can write unit tests using packages like testthat and assertthat. Unit tests help ensure that your code is working as expected and that any changes you make to your code don't introduce new bugs.

Scalability: If your code needs to handle larger datasets or more complex computations, you may need to optimize it for scalability. This could involve using parallelization, optimizing algorithms, or using more efficient data structures.
